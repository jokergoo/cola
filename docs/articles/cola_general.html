<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>cola: A Framework for Consensus Partitioning • cola</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="cola: A Framework for Consensus Partitioning">
<meta property="og:description" content="cola">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">cola</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.9.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Standard consensus partitioning</li>
    <li>
      <a href="../articles/cola_quick.html">A Quick Start of Using cola Package</a>
    </li>
    <li>
      <a href="../articles/cola_general.html">A Framework for Consensus Partitioning</a>
    </li>
    <li>
      <a href="../articles/functional_enrichment.html">Automatic Functional Enrichment on Signature genes</a>
    </li>
    <li>
      <a href="../articles/predict.html">Predict Classes for New Samples</a>
    </li>
    <li>
      <a href="../articles/work_with_big_datasets.html">Work with Big Datasets</a>
    </li>
    <li>
      <a href="../articles/compare_partitions.html">Compare Partitions</a>
    </li>
    <li>
      <a href="../articles/ATC_methods.html">ATC - More Forms</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Hierarchical partitioning</li>
    <li>
      <a href="../articles/hierarchical.html">Hierarchical consensus partitioning</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Other examples</li>
    <li>
      <a href="../articles/AML.html">Re-analyze an AML proteomics dataset</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">On public datasets</li>
    <li>
      <a href="../articles/examples.html">Applications on public datasets</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Supplementary files</li>
    <li>
      <a href="https://jokergoo.github.io/cola_supplementary/" class="external-link">Supplementary files for cola NAR paper</a>
    </li>
    <li>
      <a href="https://cola-rh.github.io/supplementary/" class="external-link">Supplementary files for cola BIB paper</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/jokergoo/cola/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>cola: A Framework for Consensus Partitioning</h1>
                        <h4 data-toc-skip class="author">Zuguang Gu (<a href="mailto:z.gu@dkfz.de" class="email">z.gu@dkfz.de</a>)</h4>
            
            <h4 data-toc-skip class="date">2024-02-27</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jokergoo/cola/blob/HEAD/vignettes/cola_general.Rmd" class="external-link"><code>vignettes/cola_general.Rmd</code></a></small>
      <div class="hidden name"><code>cola_general.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Subgroup classification is a basic task in high-throughput genomic data analysis, especially for gene expression and DNA methylation data analysis. Mostly, unsupervised clustering methods are applied to predict new subgroups or to test the agreement with known annotations.</p>
<p>To test the stability of subgroup classifications, <a href="https://en.wikipedia.org/wiki/Consensus_clustering" class="external-link">consensus clustering</a> or consensus partitioning is always performed. It clusters repeatedly with a randomly sampled subset of data and summarizes the robustness of the clustering, finally, it gives a consensus classification of all samples.</p>
<p>Here we present the <em>cola</em> package which provides a general framework for consensus partitioning. It has the following advantages:</p>
<ol style="list-style-type: decimal">
<li>It modularizes the consensus partitioning processes that various methods can be easily integrated into different steps of the analysis.</li>
<li>It provides rich visualizations for interpreting the results.</li>
<li>It allows running multiple methods at the same time and provides functionalities to compare results in a straightforward way.</li>
<li>It provides a new method to extract features which are more efficient to separate subgroups.</li>
<li>It generates detailed HTML reports for the complete analysis.</li>
</ol>
<p>Following flowchart lists the general steps of consensus partitioning implemented by <em>cola</em>:</p>
<p><img src="consensus_partition_workflow.png" width="600"></p>
<p>The steps are:</p>
<ol style="list-style-type: decimal">
<li>Clean the input matrix. The processings are: adjusting outliers, imputing missing values and removing rows with very small variance. This step is optional.</li>
<li>Extract a subset of rows with the highest scores. Here “scores” are calculated by a certain method. For gene expression analysis or methylation data analysis, <span class="math inline">\(n\)</span> rows with the highest variance are used in most studies, where the “method”, or let’s call it <strong>“the top-value method”</strong> is the variance (by <code>var()</code> or <code>sd()</code>). Note the choice of “the top-value method” can be general. It can be e.g. MAD (median absolute deviation) or any user-defined method.</li>
<li>Scale the rows in the sub-matrix (e.g. gene expression) or not (e.g. methylation data). This step is optional.</li>
<li>Randomly sample a subset of rows or columns from the sub-matrix with probability <span class="math inline">\(p\)</span> and perform partitioning on the columns of the matrix by a certain partitioning method, with trying different numbers of subgroups.</li>
<li>Repeat step 4 several times and collect all the partitions.</li>
<li>Perform consensus partitioning analysis and determine the best number of subgroups which give the most stable subgrouping.</li>
<li>Apply statistical tests to find rows that show a significant difference between the predicted subgroups. E.g. to extract subgroup-specific genes.</li>
<li>If rows in the matrix can be associated with genes, downstream analysis such as function enrichment analysis can be performed.</li>
</ol>
<p>All the steps will be explained in detail in the following sections.</p>
<p>First, we load the <em>cola</em> package.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/jokergoo/cola" class="external-link">cola</a></span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="the-input-matrix">The input matrix<a class="anchor" aria-label="anchor" href="#the-input-matrix"></a>
</h2>
<p>In most of the analysis tasks, the input matrix contains values of gene expression or DNA methylation (from methylation array or whole-genome bisulfite sequencing). If it is an expression matrix, rows correspond to genes, and if it is a methylation matrix, rows correspond to CpG sites. For both types of matrices, columns should always correspond to samples where subgroups are detected. More general, the input matrix can be any type of measurements as long as they represent in a form of a matrix, e.g. a matrix where rows are genomic regions and values are the histone modification intensities in the regions, measured from a ChIP-Seq experiment.</p>
<p>In following part of this vignette, we always call the matrix columns as “samples”.</p>
<p>Before performing consensus partitioning, a simple but important step is to clean the input matrix:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="va">mat</span> <span class="op">=</span> <span class="fu"><a href="../reference/adjust_matrix.html">adjust_matrix</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span></span></code></pre></div>
<p><code><a href="../reference/adjust_matrix.html">adjust_matrix()</a></code> does the following preprocessing:</p>
<ol style="list-style-type: decimal">
<li>Rows where more than 25% of the samples having <code>NA</code> values are removed;</li>
<li>Use <code><a href="https://rdrr.io/pkg/impute/man/impute.knn.html" class="external-link">impute::impute.knn()</a></code> to impute missing data if there is any;</li>
<li>For each row in the matrix, it uses <code><a href="../reference/adjust_outlier.html">adjust_outlier()</a></code> (also provided by <em>cola</em> package) to adjust outliers. Values larger than the 95^th percentile or less than the 5^th percentile are replaced by corresponding percentiles.</li>
<li>Rows with zero variance are removed.</li>
<li>Rows with variance less than 5^th percentile of all row variance (after removing rows with zero variance) are removed.</li>
</ol>
<p>Some of the above steps are optional. For example, methylation matrix does not need to be adjusted for outliers because all the methylation values are already in a fixed data scale (0 ~ 1).</p>
</div>
<div class="section level2">
<h2 id="basic-usage">Basic usage<a class="anchor" aria-label="anchor" href="#basic-usage"></a>
</h2>
<p><code><a href="../reference/consensus_partition.html">consensus_partition()</a></code> performs consensus partitioning for a single top-value method and a single partitioning method. The major arguments for <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code> are:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="va">res</span> <span class="op">=</span> <span class="fu"><a href="../reference/consensus_partition.html">consensus_partition</a></span><span class="op">(</span><span class="va">mat</span>,</span>
<span>    top_value_method <span class="op">=</span> <span class="st">"MAD"</span>,</span>
<span>    top_n <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fl">2000</span>, <span class="fl">3000</span><span class="op">)</span>,</span>
<span>    partition_method <span class="op">=</span> <span class="st">"kmeans"</span>,</span>
<span>    max_k <span class="op">=</span> <span class="fl">6</span>,</span>
<span>    p_sampling <span class="op">=</span> <span class="fl">0.8</span>,</span>
<span>    partition_repeat <span class="op">=</span> <span class="fl">50</span>,</span>
<span>    anno <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
<ul>
<li>
<code>mat</code>: a data matrix where subgroups are found by columns.</li>
<li>
<code>top_value_method</code>: name of the method to assign scores to matrix rows. Later these scores are used to order and extract rows with top values.</li>
<li>
<code>top_n</code>: number of rows with top values used for partitioning. Normally we set <code>top_n</code> as a vector of different numbers.</li>
<li>
<code>partition_method</code>: name of the method for partitioning.</li>
<li>
<code>max_k</code>: maximal number of subgroups to try. It will try from 2 to <code>max_k</code>.</li>
<li>
<code>p_sampling</code>: the fraction of the <code>top_n</code> rows to sample. The sub-matrix with <code>p_sample * top_n</code> rows is used for partitioning.</li>
<li>
<code>partition_repeats</code>: times of partitioning with randomly sampled subset of data to perform.</li>
<li>
<code>anno</code>: a vector or a data frame which contains known annotations of samples. If it is provided, it will be drawn alongside with the predicted subgroups in the plot generated by downstream functions and it can also be tested for the correspondence to predicted subgroups.</li>
</ul>
<p>Other arguments can be found in the documentation of <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code>.</p>
<p>To get a robust result from consensus partitioning, for a specific top-value method and a specific partitioning method, <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code> tries different <code>top_n</code> and different number of subgroups. We found that different <code>top_n</code> might give different subgroups for some data sets, thus <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code> pools results from different <code>top_n</code> and aims to give a general consensus subgrouping across different <code>top_n</code>. Later, we will introduce that the bias for <code>top_n</code> on subgrouping can be visualized by <code><a href="../reference/membership_heatmap-ConsensusPartition-method.html">membership_heatmap()</a></code> function.</p>
<p>In most cases, users might not be very sure which top-value method and which partitioning method is best for their dataset. The helper function <code><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods()</a></code> is a convenient way to try multiple top-value methods and multiple partitioning methods simultaneously to see which combination of methods gives the best prediction of subgroups.</p>
<p>In <code><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods()</a></code>, most of the arguments are the same as in <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code>, except <code>top_value_method</code> and <code>partition_method</code> now accept a vector of method names and multiple cores can be set by <code>cores</code> argument.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="va">rl</span> <span class="op">=</span> <span class="fu"><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods</a></span><span class="op">(</span><span class="va">mat</span>, </span>
<span>    top_value_method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"SD"</span>, <span class="st">"MAD"</span>, <span class="va">...</span><span class="op">)</span>,</span>
<span>    partition_method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"hclust"</span>, <span class="st">"kmeans"</span>, <span class="va">...</span><span class="op">)</span>,</span>
<span>    cores <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/cola_report-dispatch.html">cola_report</a></span><span class="op">(</span><span class="va">rl</span>, output_dir <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>There are many functions in <em>cola</em> package that can be applied to <code>rl</code> to visualize and compare the results for all combinations of methods simultaneously.</p>
<p><code><a href="../reference/cola_report-dispatch.html">cola_report()</a></code> function can be applied on <code>rl</code> to generate a HTML report for the complete analysis, with all the plots and tables.</p>
</div>
<div class="section level2">
<h2 id="top-value-methods">Top-value methods<a class="anchor" aria-label="anchor" href="#top-value-methods"></a>
</h2>
<p>Top-value methods are used to assign scores to matrix rows, later the scores are ordered and only the top <span class="math inline">\(n\)</span> rows with the highest scores are used for consensus partitioning. The default top-value methods provided in the package are:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/all_top_value_methods.html">all_top_value_methods</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "SD"  "CV"  "MAD" "ATC"</span></span></code></pre>
<p>These top methods are:</p>
<ul>
<li>
<code>SD</code>: Standard deviation.</li>
<li>
<code>CV</code>: <a href="https://en.wikipedia.org/wiki/Coefficient_of_variation" class="external-link">Coefficient of variance</a>, defined as <code>sd/(mean + s0)</code> where <code>s0</code> is a penalty term which is the 10^th percentile of all row means to avoid small values dividing small values giving large values.</li>
<li>
<code>MAD</code>: <a href="https://en.wikipedia.org/wiki/Median_absolute_deviation" class="external-link">Median absolute deviation</a>.</li>
<li>
<code>ATC</code>: A new method proposed in <em>cola</em> package and it will be explained later in this section.</li>
</ul>
<p>These methods can be used in consensus partitioning by providing the name to the <code>top_value_method</code> argument in <code><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods()</a></code> or <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code>.</p>
<p>You can register a new top-value method by <code><a href="../reference/register_top_value_methods.html">register_top_value_methods()</a></code>. The value should be functions. For each function, it should only have one argument which is the matrix for analysis and it must return a vector with scores for rows. In the following example, the “max” method uses the row maximum as the row score and we also add the “QCD” method (<a href="https://en.wikipedia.org/wiki/Quartile_coefficient_of_dispersion" class="external-link">quartile coefficient of dispersion</a>) as a second method here.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/register_top_value_methods.html">register_top_value_methods</a></span><span class="op">(</span></span>
<span>    max <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">mat</span><span class="op">)</span> <span class="fu">matrixStats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/matrixStats/man/rowRanges.html" class="external-link">rowMaxs</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span>,</span>
<span>    QCD <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">mat</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="va">qa</span> <span class="op">=</span> <span class="fu">matrixStats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/matrixStats/man/rowQuantiles.html" class="external-link">rowQuantiles</a></span><span class="op">(</span><span class="va">mat</span>, probs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.25</span>, <span class="fl">0.75</span><span class="op">)</span><span class="op">)</span></span>
<span>        <span class="op">(</span><span class="va">qa</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">qa</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="va">qa</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">qa</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span>    <span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/all_top_value_methods.html">all_top_value_methods</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "SD"  "CV"  "MAD" "ATC" "max" "QCD"</span></span></code></pre>
<p>By default, the consensus partitioning functions <code><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods()</a></code> uses all registered top-value methods, but still, you can explicitly specify a subset of top-value methods. To remove registered top-value methods, simply use <code><a href="../reference/remove_top_value_methods.html">remove_top_value_methods()</a></code> by providing a vector of names.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/remove_top_value_methods.html">remove_top_value_methods</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"max"</span>, <span class="st">"QCD"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/all_top_value_methods.html">all_top_value_methods</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "SD"  "CV"  "MAD" "ATC"</span></span></code></pre>
<div class="section level3">
<h3 id="the-atc-method">The ATC method<a class="anchor" aria-label="anchor" href="#the-atc-method"></a>
</h3>
<p>Choosing the top rows in the matrix is important for the subgroup classification. In most cases, we extract the most variable rows which is defined by row variance. However, sometimes it won’t give you meaningful rows which are efficient for subgroup classification. When random noise in the data increases, e.g. for single-cell RNASeq data, the most variable genes are too weak to detect any stable subgroups.</p>
<p>If we think reversely, assuming there exist stable subgroups in the data, there must be groups of rows showing a similar pattern to support the subgrouping, in other words, rows in the same groups should have high correlations to each other. Thus, if we can get rows that more correlated to others, they are more strong to form a stable subgroup for the samples. According to this thought, we designed the ATC method (ability to correlate to other rows).</p>
<p>For row <span class="math inline">\(i\)</span> in a matrix, <span class="math inline">\(X\)</span> is a vector of <strong>the absolute correlation</strong> to all other rows, the ATC (ability to correlate to other rows) for row <span class="math inline">\(i\)</span> is defined as:</p>
<p><span class="math display">\[ATC_i = 1 - \int_0^1F(x)\]</span></p>
<p>where <span class="math inline">\(F(x)\)</span> is the CDF (cumulative distribution function) of <span class="math inline">\(X\)</span>.</p>
<p>In the following plot, the line is the CDF curve. ATC is the area above the CDF curve. It can be imagined that when row <span class="math inline">\(i\)</span> correlates with more other rows, the CDF curve shifts more to the right, thus with higher ATC scores.</p>
<p><img src="cola_general_files/figure-html/unnamed-chunk-9-1.png" width="480" style="display: block; margin: auto;"></p>
<p>There can be scenarios when a large number of rows are correlated to each other only with very small correlation values. They will gain high ATC value due to a large number of rows (which corresponds to the left part of the red area in the above plot that is close to <span class="math inline">\(x = 0\)</span>). To decrease such effect, the ATC definition can be slightly modified to:</p>
<p><span class="math display">\[ATC_i = (1 - \alpha) - \int_{\alpha}^1F(x^{\beta})\]</span></p>
<p>where now <span class="math inline">\(ATC_i\)</span> is the red area only on the right of <span class="math inline">\(x = \alpha\)</span>. The coefficient <span class="math inline">\(\beta\)</span> is the power added to the absolute correlations that it decreases more for the smaller correlations. By Default <span class="math inline">\(\alpha\)</span> is set to 0 and <span class="math inline">\(\beta\)</span> is set to 1.</p>
<p>Next, we perform a simulation test to show the attributes of the ATC method. A matrix with 160 rows, 100 columns with random values are generated as follows:</p>
<ol style="list-style-type: decimal">
<li>100 rows with a mean of 0. The covariance matrix is set to 0 and 1 on the diagonal;</li>
<li>10 rows with a mean of 0. The covariance matrix is set to 0.8 and 1 on the diagonal. This simulates high correlations but in a small group of rows;</li>
<li>50 rows with a mean of 0. The covariance matrix is set to 0.5 and 1 on the diagonal. This simulates intermediate correlations but in a large group of rows.</li>
</ol>
<p>The top left figure in following is the heatmap for the random matrix, split by the three groups of rows. In the top right figure, they are ECDF curves of the correlation when calculating ATC scores. The bottom left figure is the ATC scores for all 160 rows and the bottom right figure is the standard deviation for the 160 rows.</p>
<p><img src="cola_general_files/figure-html/unnamed-chunk-10-1.png" width="768" style="display: block; margin: auto;"></p>
<p>All the 160 rows have a similar variance of 1 that they cannot be distinguished very well by using variance (bottom right figure). As a contrast, the rows with non-zero covariance have higher ATC values (the red and green points), even higher when the number of correlated rows increases (the green points, although the correlation value itself is intermediate, bottom left figure). This shows the ATC method can assign higher values for rows which correlate to more other rows.</p>
<p>ATC scores are calculated by <code><a href="../reference/ATC.html">ATC()</a></code> function. By default it uses Pearson correlation. Users can register the ATC method with other correlation methods by, e.g.:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="fu"><a href="../reference/register_top_value_methods.html">register_top_value_methods</a></span><span class="op">(</span></span>
<span>    ATC_spearman <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">m</span><span class="op">)</span> <span class="fu"><a href="../reference/ATC.html">ATC</a></span><span class="op">(</span><span class="va">m</span>, method <span class="op">=</span> <span class="st">"spearman"</span><span class="op">)</span>,</span>
<span>    ATC_bicor <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">m</span><span class="op">)</span> <span class="fu"><a href="../reference/ATC.html">ATC</a></span><span class="op">(</span><span class="va">m</span>, cor_fun <span class="op">=</span> <span class="fu">WGCNA</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/WGCNA/man/bicor.html" class="external-link">bicor</a></span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="partitioning-methods">Partitioning methods<a class="anchor" aria-label="anchor" href="#partitioning-methods"></a>
</h2>
<p>Partitioning methods are used to separate samples into <span class="math inline">\(k\)</span> subgroups where <span class="math inline">\(k\)</span> is a known parameter for the partitioning. The default partitioning methods are:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/all_partition_methods.html">all_partition_methods</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "hclust"  "kmeans"  "skmeans" "pam"     "mclust" </span></span>
<span><span class="co">## attr(,"scale_method")</span></span>
<span><span class="co">## [1] "z-score" "z-score" "z-score" "z-score" "z-score"</span></span></code></pre>
<p>These partitioning methods are:</p>
<ul>
<li>
<code>hclust</code>: hierarchical clustering + cutree. The parameters for calling <code><a href="https://rdrr.io/r/stats/hclust.html" class="external-link">hclust()</a></code> and <code><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist()</a></code> are all defaults for the two functions, thus it is Euclidean distance with “complete” clustering method.</li>
<li>
<code>kmeans</code>: k-means clustering.</li>
<li>
<code>skmeans</code>: spherical k-means clustering, from <strong>skmeans</strong> package.</li>
<li>
<code>pam</code>: partitioning around medoids, from <strong>cluster</strong> package.</li>
<li>
<code>mclust</code>: model-based clustering, from <strong>mclust</strong> package. The clustering is based on the first three principle dimensions from the original matrix.</li>
</ul>
<p>Similarly, you can register a new partitioning method by <code><a href="../reference/register_partition_methods.html">register_partition_methods()</a></code>. The value should be functions with two arguments which are the input matrix and number of subgroups. There can be a third argument for the function which is <code>...</code> used for passing more arguments from <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code>. The function should only return a vector of subgroup/class labels or an object that can be imported by <code><a href="https://rdrr.io/pkg/clue/man/cl_membership.html" class="external-link">clue::cl_membership()</a></code>. <strong>Please note the partition is applied on columns of the matrix and the number of unique levels of subgroup levels which are predicted by the partitioning method should not exceed <span class="math inline">\(k\)</span>.</strong></p>
<p>Following example registers a partitioning method which randomly assigns subgroup labels to samples:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/register_partition_methods.html">register_partition_methods</a></span><span class="op">(</span></span>
<span>    random <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">mat</span>, <span class="va">k</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/pkg/AnnotationDbi/man/Bimap-envirAPI.html" class="external-link">sample</a></span><span class="op">(</span><span class="va">letters</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">k</span><span class="op">]</span>, <span class="fu"><a href="../reference/ncol-dispatch.html">ncol</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Here the subgroup labels can be in any types (numbers, characters). They only need to be different for different classes. These labels will be re-coded with numeric indices internally (i.e. 1, 2, 3, …).</p>
<p>To remove a partitioning method, use <code><a href="../reference/remove_partition_methods.html">remove_partition_methods()</a></code>:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/remove_partition_methods.html">remove_partition_methods</a></span><span class="op">(</span><span class="st">"random"</span><span class="op">)</span></span></code></pre></div>
<p>The built-in <code>hclust</code> method only uses Euclidean distance with “complete” clustering method, It is easy to define another <code>hclust</code> method:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="fu"><a href="../reference/register_partition_methods.html">register_partition_methods</a></span><span class="op">(</span></span>
<span>    hclust_cor <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">mat</span>, <span class="va">k</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/cutree.html" class="external-link">cutree</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/hclust.html" class="external-link">hclust</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">as.dist</a></span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, <span class="va">k</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Following code registers SOM and NMF partitioning methods:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">kohonen</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/register_partition_methods.html">register_partition_methods</a></span><span class="op">(</span></span>
<span>    SOM <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">mat</span>, <span class="va">k</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="va">kr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">floor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fu"><a href="../reference/ncol-dispatch.html">ncol</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>        <span class="va">somfit</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/kohonen/man/supersom.html" class="external-link">som</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span>, grid <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/kohonen/man/unit.distances.html" class="external-link">somgrid</a></span><span class="op">(</span><span class="va">kr</span>, <span class="va">kr</span>, <span class="st">"hexagonal"</span><span class="op">)</span>, <span class="va">...</span><span class="op">)</span></span>
<span>        <span class="va">m</span> <span class="op">=</span> <span class="va">somfit</span><span class="op">$</span><span class="va">codes</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span>        <span class="va">m</span> <span class="op">=</span> <span class="va">m</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="fu"><a href="../reference/nrow-dispatch.html">nrow</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/pkg/BiocGenerics/man/match.html" class="external-link">%in%</a></span> <span class="va">somfit</span><span class="op">$</span><span class="va">unit.classif</span>, <span class="op">]</span></span>
<span>        <span class="va">cl</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/cutree.html" class="external-link">cutree</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/hclust.html" class="external-link">hclust</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span><span class="op">)</span>, <span class="va">k</span><span class="op">)</span></span>
<span>        <span class="va">group</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">numeric</a></span><span class="op">(</span><span class="fu"><a href="../reference/ncol-dispatch.html">ncol</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span><span class="op">)</span></span>
<span>        <span class="kw">for</span><span class="op">(</span><span class="va">cl_unique</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">cl</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>            <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">gsub</a></span><span class="op">(</span><span class="st">"V"</span>, <span class="st">""</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">cl</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/pkg/BiocGenerics/man/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">cl</span> <span class="op">==</span> <span class="va">cl_unique</span><span class="op">)</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span>            <span class="va">l</span> <span class="op">=</span> <span class="va">somfit</span><span class="op">$</span><span class="va">unit.classif</span> <span class="op"><a href="https://rdrr.io/pkg/BiocGenerics/man/match.html" class="external-link">%in%</a></span> <span class="va">ind</span></span>
<span>            <span class="va">group</span><span class="op">[</span><span class="va">l</span><span class="op">]</span> <span class="op">=</span> <span class="va">cl_unique</span></span>
<span>        <span class="op">}</span></span>
<span>        <span class="va">group</span></span>
<span>    <span class="op">}</span></span>
<span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="http://renozao.github.io/NMF/" class="external-link">NMF</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/register_partition_methods.html">register_partition_methods</a></span><span class="op">(</span></span>
<span>    NMF <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">mat</span>, <span class="va">k</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="va">fit</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/NMF/man/nmf.html" class="external-link">nmf</a></span><span class="op">(</span><span class="va">mat</span>, rank <span class="op">=</span> <span class="va">k</span>, <span class="va">...</span><span class="op">)</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">fit</span><span class="op">@</span><span class="va">fit</span><span class="op">@</span><span class="va">H</span>, <span class="fl">2</span>, <span class="va">which.max</span><span class="op">)</span></span>
<span>    <span class="op">}</span>, scale_method <span class="op">=</span> <span class="st">"max-min"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>For these two methods, users can simply use <code><a href="../reference/register_SOM.html">register_SOM()</a></code> and <code><a href="../reference/register_NMF.html">register_NMF()</a></code> functions in <em>cola</em> package.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="fu"><a href="../reference/register_SOM.html">register_SOM</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/register_NMF.html">register_NMF</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>In the code above, there is an additional argument <code>scale_method</code> for <code>register_partition_method()</code>. <code>scale_method</code> controls how to scale the matrix rows before partitioning if scaling is turned on <code><a href="../reference/consensus_partition.html">consensus_partition()</a></code> or <code><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods()</a></code>. There are three possible values:</p>
<ul>
<li>
<code>z-score</code>: z-score transformation, which is <code>(x - mean(x))/sd(x)</code>.</li>
<li>
<code>max-min</code>: <code>(x - min(x))/(max(x) - min(x))</code>, this ensures all the scaled values are non-negative.</li>
<li>
<code>none</code>: no scaling is performed.</li>
</ul>
<div class="section level3">
<h3 id="the-skmeans-method">The skmeans method<a class="anchor" aria-label="anchor" href="#the-skmeans-method"></a>
</h3>
<p>The skmeans method (<a href="https://www.jstatsoft.org/article/view/v050i10" class="external-link">the spherical k-means clustering</a>) is powerful to detect subgroups where samples in the same subgroup show strong correlations. skmeans clustering uses cosine similarity and projects data points onto a unit hyper-sphere. As we have tested for many datasets, skmeans is very efficient to detect stable subgroups.</p>
<p><img src="skmeans.png" width="400"></p>
</div>
</div>
<div class="section level2">
<h2 id="consensus-partitioning">Consensus partitioning<a class="anchor" aria-label="anchor" href="#consensus-partitioning"></a>
</h2>
<p>For a given number of top rows <span class="math inline">\(n_i\)</span>, the corresponding matrix with top rows denoted as <span class="math inline">\(M_i\)</span>, a subset of rows with a probability of <span class="math inline">\(p\)</span> are randomly sampled from <span class="math inline">\(M_i\)</span> and a certain partitioning method is applied to it, generating a partition <span class="math inline">\(P_a\)</span>. In most cases, we have no prior knowledge of which <span class="math inline">\(n_i\)</span> gives better results, thus, <em>cola</em> allows to try multiple <span class="math inline">\(n_i\)</span> and pool partitions from all <span class="math inline">\(n_i\)</span> together to find a consensus subgrouping, which also lets rows more on the top of the ranked list give higher weight for determining the final subgroups. Let’s assume top rows are tried for <span class="math inline">\(n_1\)</span>, <span class="math inline">\(n_2\)</span>, …, <span class="math inline">\(n_m\)</span> and the randomly sampling is performed for <span class="math inline">\(N_s\)</span> times, then, for a given number of subgroups <span class="math inline">\(k\)</span> for trying, the total number of partitions is <span class="math inline">\(N_P = m \times N_s\)</span>.</p>
<div class="section level3">
<h3 id="consensus-matrix">Consensus matrix<a class="anchor" aria-label="anchor" href="#consensus-matrix"></a>
</h3>
<p>The consensus matrix measures how consistent two samples are in the same subgroup and it can be used to visualize or analysis the stability of the subgrouping. The value <span class="math inline">\(c_{ij}\)</span> in the consensus matrix is the probability of sample <span class="math inline">\(i\)</span> and sample <span class="math inline">\(j\)</span> in the same subgroup in all <span class="math inline">\(N_P\)</span> partitions. It is calculated as:</p>
<p><span class="math display">\[c_{ij} = \sum_a^{N_P}I(s_{ia}, s_{ja})/N_P\]</span></p>
<p>where <span class="math inline">\(s_{ia}\)</span> is the subgroup label for sample <span class="math inline">\(i\)</span> in partition <span class="math inline">\(a\)</span> and <span class="math inline">\(I()\)</span> is the indicator function there <span class="math inline">\(I(x = y) = 1\)</span> and <span class="math inline">\(I(x \neq y) = 0\)</span>.</p>
<p>Assuming there are stable subgroups in a dataset, which means, for any pair of samples <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> both in a same subgroup, <span class="math inline">\(c_{ij}\)</span> is close to 1, and for any pairs in different subgroups, <span class="math inline">\(c_{ij}\)</span> is close to 0, if the consensus matrix is visualized as a heatmap, samples in the same subgroup will be represented as a block in the diagonal of the heatmap.</p>
<p>Following two heatmaps visualize two consensus matrices. The left one shows less stability of subgrouping than the right one, while for the right one, there are three very obvious blocks in the diagonal that in each block, the corresponding samples are very likely to be in the same subgroup.</p>
<p>In the following two heatmaps, the right one corresponds to a more stable subgrouping.</p>
<p><img src="cola_general_files/figure-html/unnamed-chunk-18-1.png" width="864" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="consensus-subgroup-labels">Consensus subgroup labels<a class="anchor" aria-label="anchor" href="#consensus-subgroup-labels"></a>
</h3>
<p>As long as we have a list of <span class="math inline">\(N_P\)</span> partitions for a given subgroup number <span class="math inline">\(k\)</span>, we need to find a consensus partition based on all <span class="math inline">\(N_P\)</span> partitions.Internally, <em>cola</em> package uses the <strong>clue</strong> package to construct the “partition ensemble” and predict the consensus subgroups. The “SE” method from <code><a href="https://rdrr.io/pkg/clue/man/cl_consensus.html" class="external-link">clue::cl_consensus()</a></code> function (please check the on-line documentation of this function) are used to calculate the consensus subgroup labels. The consensus subgroups are labels by integers (i.e. 1, 2, 3, …).</p>
</div>
<div class="section level3">
<h3 id="adjust-subgroup-labels">Adjust subgroup labels<a class="anchor" aria-label="anchor" href="#adjust-subgroup-labels"></a>
</h3>
<p>The subgroup labels are assigned with numeric indices, however, in each partition, the assignment of the labels can be random, e.g. one same subgroup can be assigned with 1 in one partition, while in the other partition, it can be 2, but they are all identical for the sense of subgrouping. E.g. following partitions are all identical:</p>
<pre><code>1 1 1 1 1 1 1 2 2 2 2 2 2
2 2 2 2 2 2 2 1 1 1 1 1 1
a a a a a a a b b b b b b</code></pre>
<p>The subgroups are identical if switching the subgroup labels. This subgroup label adjustment is called <a href="https://en.wikipedia.org/wiki/Assignment_problem" class="external-link">the linear sum assignment problem</a>, which is solved by the <code>solve_LSAP()</code> function in <strong>clue</strong> package. The aim is to find a mapping <span class="math inline">\(m()\)</span> between two sets of labels to maximize <span class="math inline">\(\sum_i I(s_{1i}, m(s_{2i}))\)</span> where <span class="math inline">\(s_1\)</span> is the first label set and <span class="math inline">\(s_2\)</span> is the second label set.</p>
<p>In following example, if the mapping is <code>1 -&gt; 2, 2 -&gt; 1</code>, the second partition in following</p>
<pre><code>1 1 1 1 1 1 1 2 2 2 2 2 # in partition 1
2 2 2 2 2 1 1 1 1 1 1 1 # in partition 2</code></pre>
<p>is adjusted to</p>
<pre><code>1 1 1 1 1 1 1 2 2 2 2 2
1 1 1 1 1 2 2 2 2 2 2 2 # switch 1 &lt;-&gt; 2</code></pre>
<p>For the subgroups predicted by <code><a href="https://rdrr.io/pkg/clue/man/cl_consensus.html" class="external-link">clue::cl_consensus()</a></code>, the labels are additionally adjusted by the mean distance in each subgroup (calculated from the scaled data matrix), which means, the subgroup with label 1 always has the smallest mean intra-group distance.</p>
<p><strong>This subgroup label adjustment is frequently used in <em>cola</em> to help the visualization as well as downstream analysis. E.g. for a specific combination of top-value method and partitioning method, the subgroup labels for different k are adjusted, and for the subgroups from different top-value methods and partitioning methods, the subgroup labels are also adjusted to make the label difference from different methods minimal.</strong></p>
</div>
<div class="section level3">
<h3 id="membership-matrix">Membership matrix<a class="anchor" aria-label="anchor" href="#membership-matrix"></a>
</h3>
<p>The <span class="math inline">\(N_P\)</span> partitions are stored as a membership matrix where rows are partitions (grouped by <code>top_n</code>) and the subgroup labels in each partition are adjusted according to the consensus partition. Following heatmap is a visualization of all partitions and correspondence to the consensus partition for <span class="math inline">\(k = 2\)</span>. The <code>p*</code> annotation on top of the heatmap is the probability of being in subgroup <span class="math inline">\(i\)</span> across all partitions.</p>
<p>In the following plot, actually we can see the samples in the middle tend to belong to the green subgroup (the group with label 1) for small <code>top_n</code> (e.g. <code>top_n = 1000</code>), while, when <code>top_n</code> increases, they go to the red subgroup (group label 2). Since the final subgroups are summarized from all <code>top_n</code>, the probabilities of the middle samples to be in either subgroup are close, which can also be observed from the probability annotation (<code>p*</code> annotations). This might indicate these are the subset of samples which are in the intermediate state between group 1 and group 2.</p>
<p><img src="membership_heatmap.png"></p>
</div>
</div>
<div class="section level2">
<h2 id="determine-the-best-number-of-subgroups">Determine the best number of subgroups<a class="anchor" aria-label="anchor" href="#determine-the-best-number-of-subgroups"></a>
</h2>
<p>Consensus partitioning is applied with a specific number of subgroups (we term it as <span class="math inline">\(k\)</span>). Normally, a list of <span class="math inline">\(k\)</span> are tried to find the best <span class="math inline">\(k\)</span>. <em>cola</em> provides metrics to help to determine the best number of subgroups.</p>
<p>The <code><a href="../reference/get_stats-dispatch.html">get_stats()</a></code> function returns statistics for all metrics mentioned below and <code><a href="../reference/select_partition_number-ConsensusPartition-method.html">select_partition_number()</a></code> plots the statistics with the number of subgroups (an example is <a href="#toc_25">here</a>).</p>
<div class="section level3">
<h3 id="silhouette-score">Silhouette score<a class="anchor" aria-label="anchor" href="#silhouette-score"></a>
</h3>
<p><a href="https://en.wikipedia.org/wiki/Silhouette_%28clustering%29" class="external-link">The silhouette scores</a> measures how close one sample is in its own subgroup compared to the closest neighbouring subgroup. For sample <span class="math inline">\(i\)</span>, the mean distance to every subgroups are calculated, denoted as <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>, …, <span class="math inline">\(d_k\)</span> (<span class="math inline">\(d_k\)</span> is the mean Euclidean distance between sample <span class="math inline">\(i\)</span> and every sample in subgroup <span class="math inline">\(s\)</span>). The distance to the subgroup where sample <span class="math inline">\(i\)</span> stays is denoted as <span class="math inline">\(d_a\)</span> and the silhouette score is defined as:</p>
<p><span class="math display">\[silhouette_i = 1 - d_a/d_b\]</span></p>
<p>where <span class="math inline">\(d_b\)</span> is the minimal distance excluding <span class="math inline">\(d_a\)</span>:</p>
<p><span class="math display">\[d_b = min_{j \neq a}^k d_j\]</span></p>
<p>Following plot illustrates how silhouette score is calculated for sample <code>x_i</code>.</p>
<p><img src="cola_general_files/figure-html/unnamed-chunk-19-1.png" width="576" style="display: block; margin: auto;"></p>
<p>The mean silhouette score from all samples is used to choose the best <span class="math inline">\(k\)</span> where higher the mean silhouette score, better the <span class="math inline">\(k\)</span>.</p>
</div>
<div class="section level3">
<h3 id="pac-score">PAC score<a class="anchor" aria-label="anchor" href="#pac-score"></a>
</h3>
<p><a href="https://en.wikipedia.org/wiki/Consensus_clustering#Over-interpretation_potential_of_consensus_clustering" class="external-link">The PAC score</a> measures the proportion of the ambiguous subgrouping. If the subgrouping is stable, in <span class="math inline">\(N_P\)</span> partitions, sample <span class="math inline">\(i\)</span> and sample <span class="math inline">\(j\)</span>, in most of the cases, are either always in the same subgroup, or always in different subgroups, which results in that, in the consensus matrix, the values are, in most cases, close to 1 or 0. Then in the CDF of the consensus matrix, the curve will be very flattened between <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> where <span class="math inline">\(x_1\)</span> is very close to 0 and <span class="math inline">\(x_2\)</span> is very close to 1 because there are very few values between <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>. Thus, the proportion of sample pairs with consensus values in <span class="math inline">\((x_1, x_2)\)</span> is called <strong>the proportion of the ambiguous clustering</strong>, which can be calculated by <span class="math inline">\(F(x_2) - F(x_1)\)</span>.</p>
<p>In the following plots, the red line in the left plot corresponds to the first consensus heatmap and the blue line corresponds to the second consensus heatmap that is more stable than the first one. It is quite obvious to see the second consensus heatmap has far less PAC value than the first one.</p>
<p><img src="cola_general_files/figure-html/unnamed-chunk-20-1.png" width="1344" style="display: block; margin: auto;"></p>
<p>In some cases, <span class="math inline">\(F(x_1)\)</span> or <span class="math inline">\(F(x_2)\)</span> changes a lot when <span class="math inline">\(x_1\)</span> has slight change around 0.1, or <span class="math inline">\(x_2\)</span> has slight change around 0.9. Thus, to make PAC not so sensitive to the selection of <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>, PAC value is calculated by removing 5% samples with lowest silhouette scores.</p>
<p>Smaller the PAC score, better the <span class="math inline">\(k\)</span>.</p>
</div>
<div class="section level3">
<h3 id="concordance">Concordance<a class="anchor" aria-label="anchor" href="#concordance"></a>
</h3>
<p>The concordance of partitions to the consensus partition is calculated as, for each partition <span class="math inline">\(P_a\)</span>, the probability that it fits the consensus partition:</p>
<p><span class="math display">\[c_{a} = \frac{1}{N_s}\sum_i^{N_s}I(s_{ia} = sc_i)\]</span></p>
<p>where <span class="math inline">\(N_s\)</span> is the number of samples, <span class="math inline">\(s_{ia}\)</span> is the subgroup label of sample <span class="math inline">\(i\)</span> in partition <span class="math inline">\(a\)</span> and <span class="math inline">\(sc_i\)</span> is the consensus subgroup label for sample <span class="math inline">\(i\)</span>. Note class labels in single partitions have already been adjusted to the consensus partition labels.</p>
<p>The final concordance score is the mean value of <span class="math inline">\(c_a\)</span>. Higher the concordance score, better the <span class="math inline">\(k\)</span>.</p>
</div>
<div class="section level3">
<h3 id="area-increased">Area increased<a class="anchor" aria-label="anchor" href="#area-increased"></a>
</h3>
<p>It is the increased area under CDF of the consensus matrix compared to the previous <span class="math inline">\(k\)</span>.</p>
<p><span class="math display">\[A_k = \int F_k(x) - \int F_{k-1}(x)\]</span></p>
<p>and when <span class="math inline">\(k = 2\)</span> or for the minimal <span class="math inline">\(k\)</span>:</p>
<p><span class="math display">\[A_k = \int F_k(x)\]</span></p>
<p>In follow example, there are five consensus heatmaps corresponding to <span class="math inline">\(k =2,3,4,5,6\)</span>. Note the number of subgroups that can be inferred from the consensus heatmap is not necessary to be exactly the same as <span class="math inline">\(k\)</span>. It can be smaller than <span class="math inline">\(k\)</span>.</p>
<p><img src="cola_general_files/figure-html/unnamed-chunk-21-1.png" width="1344" style="display: block; margin: auto;"></p>
<p>The corresponding CDF curves and the area increased are:</p>
<p><img src="cola_general_files/figure-html/unnamed-chunk-22-1.png" width="960" style="display: block; margin: auto;"></p>
<p>The <span class="math inline">\(k\)</span> before the elbow is taken as the best <span class="math inline">\(k\)</span> (in the above example it is 3). Basically when <span class="math inline">\(k\)</span> reaches a stable subgrouping, increasing <span class="math inline">\(k\)</span> won’t change the consensus matrix too much, which results in less change of the difference of The area under the CDF curve.</p>
</div>
<div class="section level3">
<h3 id="rand-index">Rand index<a class="anchor" aria-label="anchor" href="#rand-index"></a>
</h3>
<p>In some cases, when the number of subgroups changes from <span class="math inline">\(k-1\)</span> to <span class="math inline">\(k\)</span>, all the statistics imply <span class="math inline">\(k\)</span> is a better choice than <span class="math inline">\(k-1\)</span>. However, when observing the consensus heatmap, basically it is because a very small set of samples are separated to form a new subgroup. In this case, it is better to still keep <span class="math inline">\(k-1\)</span> subgroups. In other words, the subgrouping with <span class="math inline">\(k\)</span> is similar to <span class="math inline">\(k-1\)</span> and it is not worth to increase <span class="math inline">\(k\)</span> from <span class="math inline">\(k-1\)</span>. In <em>cola</em> package, there are two metrics: the Rand index and Jaccard index to measure the similarity of two partitions for <span class="math inline">\(k-1\)</span> and <span class="math inline">\(k\)</span>. The two metrics are calculated by <code>clue::cl_agreement(..., method = "Rand")</code> and <code>clue::cl_agreement(..., method = "Jaccard")</code>.</p>
<p>For all pairs of samples, denote following symbols (<a href="https://en.wikipedia.org/wiki/Rand_index#Definition" class="external-link uri">https://en.wikipedia.org/wiki/Rand_index#Definition</a>):</p>
<ul>
<li>
<span class="math inline">\(a\)</span>: the number of pairs of samples that are in the same subgroup in <span class="math inline">\(k\)</span> and in the same subgroup in <span class="math inline">\(k-1\)</span>.</li>
<li>
<span class="math inline">\(b\)</span>: the number of pairs of samples that are in the different subgroup in <span class="math inline">\(k\)</span> and in the different subgroup in <span class="math inline">\(k-1\)</span>.</li>
<li>
<span class="math inline">\(c\)</span>: the number of pairs of samples that are in the same subgroup in <span class="math inline">\(k\)</span> and in the different subgroup in <span class="math inline">\(k-1\)</span>.</li>
<li>
<span class="math inline">\(d\)</span>: the number of pairs of samples that are in the different subgroup in <span class="math inline">\(k\)</span> and in the same subgroup in <span class="math inline">\(k-1\)</span>.</li>
</ul>
<p>the Rand index which is the percent of pairs of samples that are both in a same cluster or both are not in the same cluster in the partition of <span class="math inline">\(k\)</span> and <span class="math inline">\(k-1\)</span>.</p>
<p><span class="math display">\[Rand = \frac{a+b}{a+b+c+d}\]</span></p>
<p>If Rand index is too high, it means the two subgroupings are very similar and it is not sufficient to increase from <span class="math inline">\(k-1\)</span> to <span class="math inline">\(k\)</span>.</p>
</div>
<div class="section level3">
<h3 id="jaccard-index">Jaccard index<a class="anchor" aria-label="anchor" href="#jaccard-index"></a>
</h3>
<p>The Jaccard index is the ratio of pairs of samples that are both in a same subgroup in the partition of <span class="math inline">\(k\)</span> and <span class="math inline">\(k-1\)</span> and the pairs of samples are both in the same subgroup in the partition of <span class="math inline">\(k\)</span> or <span class="math inline">\(k-1\)</span>.</p>
<p><span class="math display">\[Jaccard = \frac{a}{a+c+d}\]</span></p>
<p>In the following plots, when the number of subgroups increases from 3 to 4, there is only one single sample separated from other subgroups to form a new subgroup. The Rand index or the Jaccard index for <span class="math inline">\(k=4\)</span> is close to 1, which means, the subgroups at <span class="math inline">\(k=4\)</span> are highly similar as <span class="math inline">\(k=3\)</span>, thus we ignore <span class="math inline">\(k=4\)</span> and take <span class="math inline">\(k=3\)</span> as the better subgrouping.</p>
<p><img src="rand_jaccard.png" width="600"></p>
</div>
<div class="section level3">
<h3 id="rule">Rule<a class="anchor" aria-label="anchor" href="#rule"></a>
</h3>
<p><em>cola</em> provides a <code><a href="../reference/suggest_best_k-dispatch.html">suggest_best_k()</a></code> function which suggests the best <span class="math inline">\(k\)</span>. It is based on the following rules:</p>
<ul>
<li>All <span class="math inline">\(k\)</span> with Jaccard index larger than 0.95 are removed because increasing <span class="math inline">\(k\)</span> does not provide enough extra information. If all <span class="math inline">\(k\)</span> are removed, it is marked as no subgroup is detected.</li>
<li>For all <span class="math inline">\(k\)</span> with 1-PAC score larger than 0.9, the maximal <span class="math inline">\(k\)</span> is taken as the best <span class="math inline">\(k\)</span>, and other <span class="math inline">\(k\)</span> are marked as optional <span class="math inline">\(k\)</span>.</li>
<li>If it does not fit the second rule. The <span class="math inline">\(k\)</span> with the maximal vote of the highest 1-PAC score, highest mean silhouette, and highest concordance is taken as the best <span class="math inline">\(k\)</span>.</li>
</ul>
<p><code><a href="../reference/suggest_best_k-dispatch.html">suggest_best_k()</a></code> only gives suggestion on selecting a reasonable <span class="math inline">\(k\)</span>. Users still need to look at the plots (e.g. by <code><a href="../reference/select_partition_number-ConsensusPartition-method.html">select_partition_number()</a></code> or <code><a href="../reference/consensus_heatmap-ConsensusPartition-method.html">consensus_heatmap()</a></code> functions), or even by checking whether the subgrouping gives reasonable signatures by <code><a href="../reference/get_signatures-dispatch.html">get_signatures()</a></code>, to pick a reasonable <span class="math inline">\(k\)</span> that best explains their studies.</p>
</div>
</div>
<div class="section level2">
<h2 id="find-signatures">Find signatures<a class="anchor" aria-label="anchor" href="#find-signatures"></a>
</h2>
<p>As long as there are stable subgroups, we can look for rows which show A distinct difference in one subgroup compared to others. They can be called signature genes or signature CpG sites if the corresponding dataset is gene expression data or methylation data.</p>
<p>By default, samples with silhouette scores less than 0.5 are removed. <em>cola</em> provides the following methods:</p>
<ul>
<li>
<code>Ftest</code> use F-test to find significantly different rows between subgroups.</li>
<li>
<code>ttest</code>: First it looks for the subgroup with the highest mean value, compare to each of the other subgroups with t-test and take the maximum p-value. Second it looks for the subgroup with lowest mean value, compare to each of the other subgroups again with t-test and take the maximum p-values. Later for these two lists of p-values take the minimal p-value as the final p-value.</li>
<li>
<code>samr</code> and <code>pamr</code>: use <a href="https://CRAN.R-project.org/package=samr" class="external-link">SAM</a>/<a href="https://CRAN.R-project.org/package=pamr" class="external-link">PAM</a> method to find significantly different rows between subgroups.</li>
<li>
<code>one_vs_others</code> For each subgroup <span class="math inline">\(i\)</span> in each row, it uses t-test to compare samples in current subgroup to all other samples, denoted as <span class="math inline">\(p_i\)</span>. The p-value for current row is selected as <span class="math inline">\(min(p_i)\)</span>.</li>
<li>
<code>uniquely_high_in_one_group</code> The signatures are defined as, if they are uniquely up-regulated in subgroup A, then it must fit followingcriterions: 1. in a two-group t-test of A ~ other_merged_groups, the statistic must be &gt; 0 (high in group A) and p-value must be significant, and 2. for other groups (excluding A), t-test in every pair of groups should not be significant.</li>
</ul>
<p>Users can also provide their own method by providing a function with the matrix and subgroup labels as inputs and a vector of FDR as output.</p>
</div>
<div class="section level2">
<h2 id="functional-enrichment">Functional Enrichment<a class="anchor" aria-label="anchor" href="#functional-enrichment"></a>
</h2>
<p>If the matrix rows can correspond to genes (e.g. the gene expression matrix, or the methylation array data where CpG sites can be annotated to the transcription start site of genes), <em>cola</em> performs functional enrichment by <code><a href="../reference/functional_enrichment-dispatch.html">functional_enrichment()</a></code> function with hypergeometric test to the signatures by <em>ClusterProfiler</em>, <em>DOSE</em> or <em>ReactomePA</em> packages. k-means clustering with automatically selecting the number of groups of the signature is performed and functional enrichment is applied to each row signature group, to the fact that there may exist different expression patterns and genes involved may play different functional roles.</p>
<p>More details on functional enrichment analysis can be found in the vignette <a href="functional_enrichment.html">“Automatic Functional Enrichment on Signature Genes”</a>.</p>
</div>
<div class="section level2">
<h2 id="compare-multiple-methods">Compare multiple methods<a class="anchor" aria-label="anchor" href="#compare-multiple-methods"></a>
</h2>
<p><code><a href="../reference/consensus_partition.html">consensus_partition()</a></code> is the core function for consensus partitioning. But it can only perform analysis with a single top-value method and a single partitioning method. In most cases, we have no idea of which combination of top-value method and partitioning method gives better results. Here <code><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods()</a></code> can perform analysis with multiple methods simultaneously:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="va">rl</span> <span class="op">=</span> <span class="fu"><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods</a></span><span class="op">(</span><span class="va">mat</span>, </span>
<span>    top_value_method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"SD"</span>, <span class="st">"MAD"</span>, <span class="va">...</span><span class="op">)</span>,</span>
<span>    partition_method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"hclust"</span>, <span class="st">"kmeans"</span>, <span class="va">...</span><span class="op">)</span>,</span>
<span>    cores <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>By default it runs analysis for all combinations of top-value methods in <code><a href="../reference/all_top_value_methods.html">all_top_value_methods()</a></code> and partitioning methods in <code><a href="../reference/all_partition_methods.html">all_partition_methods()</a></code>.</p>
<p><em>cola</em> package provides functions to collect plots from all combinations of methods for straightforward comparisons.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="fu"><a href="../reference/collect_plots-dispatch.html">collect_plots</a></span><span class="op">(</span><span class="va">rl</span>, fun <span class="op">=</span> <span class="va">consensus_heatmap</span>, k <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/collect_plots-dispatch.html">collect_plots</a></span><span class="op">(</span><span class="va">rl</span>, fun <span class="op">=</span> <span class="va">membership_heatmap</span>, k <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/collect_plots-dispatch.html">collect_plots</a></span><span class="op">(</span><span class="va">rl</span>, fun <span class="op">=</span> <span class="va">get_signatures</span>, k <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>And <code><a href="../reference/collect_classes-dispatch.html">collect_classes()</a></code> compares consensus partition from all methods:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="fu"><a href="../reference/collect_classes-dispatch.html">collect_classes</a></span><span class="op">(</span><span class="va">rl</span>, k <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>The plots from <code><a href="../reference/collect_plots-dispatch.html">collect_plots()</a></code> and <code><a href="../reference/collect_classes-dispatch.html">collect_classes()</a></code> can be found <a href="#toc_27">here</a>.</p>
</div>
<div class="section level2">
<h2 id="implementation-of-the-package">Implementation of the package<a class="anchor" aria-label="anchor" href="#implementation-of-the-package"></a>
</h2>
<p><em>cola</em> is implemented in an object-oriented way. There are two main classes where <code>ConsensusPartition</code> class contains results for a single top-value method and a single partitioning method, while <code>ConsensusPartitionList</code> class contains results for multiple top-value methods and multiple partitioning methods.</p>
<p>In the following example code, we use the analysis on Golub dataset. The more information of how to generate <code>golub_cola</code> can be find by <code><a href="../reference/golub_cola.html">?golub_cola</a></code>.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">golub_cola</span><span class="op">)</span></span></code></pre></div>
<p>Simply entering the variable name gives you the summary of the analysis and a list of functions that can be applied to this object:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">golub_cola</span></span></code></pre></div>
<pre><code><span><span class="co">## A 'ConsensusPartitionList' object with 20 methods.</span></span>
<span><span class="co">##   On a matrix with 4116 rows and 72 columns.</span></span>
<span><span class="co">##   Top rows are extracted by 'SD, CV, MAD, ATC' methods.</span></span>
<span><span class="co">##   Subgroups are detected by 'hclust, kmeans, skmeans, pam, mclust' method.</span></span>
<span><span class="co">##   Number of partitions are tried for k = 2, 3, 4, 5, 6.</span></span>
<span><span class="co">##   Performed in total 5000 partitions by row resampling.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Following methods can be applied to this 'ConsensusPartitionList' object:</span></span>
<span><span class="co">##  [1] "cola_report"           "collect_classes"       "collect_plots"         "collect_stats"        </span></span>
<span><span class="co">##  [5] "colnames"              "functional_enrichment" "get_anno"              "get_anno_col"         </span></span>
<span><span class="co">##  [9] "get_classes"           "get_matrix"            "get_membership"        "get_stats"            </span></span>
<span><span class="co">## [13] "is_best_k"             "is_stable_k"           "ncol"                  "nrow"                 </span></span>
<span><span class="co">## [17] "rownames"              "show"                  "suggest_best_k"        "test_to_known_factors"</span></span>
<span><span class="co">## [21] "top_rows_heatmap"      "top_rows_overlap"     </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## You can get result for a single method by, e.g. object["SD", "hclust"] or object["SD:hclust"]</span></span>
<span><span class="co">## or a subset of methods by object[c("SD", "CV")], c("hclust", "kmeans")]</span></span></code></pre>
<p>To get results for a single top-value method and partitioning method, you can subset <code>golub_cola</code> by the name of the combination of the methods.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">golub_cola</span><span class="op">[</span><span class="st">"ATC:skmeans"</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## A 'ConsensusPartition' object with k = 2, 3, 4, 5, 6.</span></span>
<span><span class="co">##   On a matrix with 4116 rows and 72 columns.</span></span>
<span><span class="co">##   Top rows (412) are extracted by 'ATC' method.</span></span>
<span><span class="co">##   Subgroups are detected by 'skmeans' method.</span></span>
<span><span class="co">##   Performed in total 250 partitions by row resampling.</span></span>
<span><span class="co">##   Best k for subgroups seems to be 3.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Following methods can be applied to this 'ConsensusPartition' object:</span></span>
<span><span class="co">##  [1] "cola_report"             "collect_classes"         "collect_plots"          </span></span>
<span><span class="co">##  [4] "collect_stats"           "colnames"                "compare_partitions"     </span></span>
<span><span class="co">##  [7] "compare_signatures"      "consensus_heatmap"       "dimension_reduction"    </span></span>
<span><span class="co">## [10] "functional_enrichment"   "get_anno"                "get_anno_col"           </span></span>
<span><span class="co">## [13] "get_classes"             "get_consensus"           "get_matrix"             </span></span>
<span><span class="co">## [16] "get_membership"          "get_param"               "get_signatures"         </span></span>
<span><span class="co">## [19] "get_stats"               "is_best_k"               "is_stable_k"            </span></span>
<span><span class="co">## [22] "membership_heatmap"      "ncol"                    "nrow"                   </span></span>
<span><span class="co">## [25] "plot_ecdf"               "predict_classes"         "rownames"               </span></span>
<span><span class="co">## [28] "select_partition_number" "show"                    "suggest_best_k"         </span></span>
<span><span class="co">## [31] "test_to_known_factors"   "top_rows_heatmap"</span></span></code></pre>
<p>Functions on <code>ConsensusPartitionList</code> class that are important to use are:</p>
<ul>
<li>
<code><a href="../reference/cola_report-dispatch.html">cola_report()</a></code>: Generate a HTML report for the complete analysis.</li>
<li>
<code><a href="../reference/collect_classes-dispatch.html">collect_classes()</a></code>: Plots consensus partition for every combination of methods. On top there is a global consensus partition summarized from all single-method-level partitions, weighted by the mean silhoutte scores.</li>
<li>
<code><a href="../reference/collect_plots-dispatch.html">collect_plots()</a></code>: Collect plots for all methods.</li>
<li>
<code><a href="../reference/get_classes-dispatch.html">get_classes()</a></code>: The global consensus subgroup by taking subgroups from all methods together.</li>
<li>
<code><a href="../reference/get_stats-dispatch.html">get_stats()</a></code>: Extract the statistics for determining the best number of subgroups.</li>
<li>
<code><a href="../reference/suggest_best_k-dispatch.html">suggest_best_k()</a></code>: Guess the best <span class="math inline">\(k\)</span> for each method.</li>
<li>
<code><a href="../reference/test_to_known_factors-dispatch.html">test_to_known_factors()</a></code>: Apply tests to the annotations if provides. The test will be Chi-squared test or ANOVA depending on the data type of the annotation.</li>
<li>
<code><a href="../reference/top_rows_heatmap-dispatch.html">top_rows_heatmap()</a></code>: Make heatmaps for <code>top_n</code> rows under different top-value methods.</li>
<li>
<code><a href="../reference/top_rows_overlap-dispatch.html">top_rows_overlap()</a></code>: Make Venn-Euler diagram for the <code>top_n</code> rows under different top-value methods.</li>
<li>
<code><a href="../reference/functional_enrichment-dispatch.html">functional_enrichment()</a></code>: If rows can be associated to genes, it applies functional enrichment analysis.</li>
</ul>
<p>Functions on <code>ConsensusPartition</code> class:</p>
<ul>
<li>
<code><a href="../reference/collect_classes-dispatch.html">collect_classes()</a></code>: Make heatmaps for the consensus subgroups from all <span class="math inline">\(k\)</span>.</li>
<li>
<code><a href="../reference/collect_plots-dispatch.html">collect_plots()</a></code>: Collect all plots for consensus heatmaps, membership heatmaps and signature heatmaps for all <span class="math inline">\(k\)</span>.</li>
<li>
<code><a href="../reference/consensus_heatmap-ConsensusPartition-method.html">consensus_heatmap()</a></code>: Make consensus heatmap.</li>
<li>
<code><a href="../reference/dimension_reduction-dispatch.html">dimension_reduction()</a></code>: Make PCA/MDS/UMAP/t-SNE plot.</li>
<li>
<code><a href="../reference/get_classes-dispatch.html">get_classes()</a></code>: Get class labels for a specific <span class="math inline">\(k\)</span>.</li>
<li>
<code><a href="../reference/get_consensus-ConsensusPartition-method.html">get_consensus()</a></code>: Get the consensus matrix for a specific <span class="math inline">\(k\)</span>.</li>
<li>
<code><a href="../reference/get_signatures-dispatch.html">get_signatures()</a></code>: Make the heatmap for the signatures.</li>
<li>
<code><a href="../reference/compare_signatures-dispatch.html">compare_signatures()</a></code>: Compare signatures for different k.</li>
<li>
<code><a href="../reference/get_stats-dispatch.html">get_stats()</a></code>: Extract the statistics for determining best number of subgroups.</li>
<li>
<code><a href="../reference/suggest_best_k-dispatch.html">suggest_best_k()</a></code>: Guess the best <span class="math inline">\(k\)</span>.</li>
<li>
<code><a href="../reference/membership_heatmap-ConsensusPartition-method.html">membership_heatmap()</a></code>: Make the membership heatmap.</li>
<li>
<code><a href="../reference/plot_ecdf-ConsensusPartition-method.html">plot_ecdf()</a></code>: Plot the emperical CDF of the consensus matrix for all <span class="math inline">\(k\)</span>.</li>
<li>
<code><a href="../reference/select_partition_number-ConsensusPartition-method.html">select_partition_number()</a></code>: Make plots for all statistics for determining the best <span class="math inline">\(k\)</span>.</li>
<li>
<code><a href="../reference/test_to_known_factors-dispatch.html">test_to_known_factors()</a></code>: Apply tests to the annotations if provides. The test will be Fisher’s exact test or ANOVA depending on the data type of the annotation.</li>
<li>
<code><a href="../reference/functional_enrichment-dispatch.html">functional_enrichment()</a></code>: If rows can be associated to genes, it applies functional enrichment analysis.</li>
<li>
<code><a href="../reference/predict_classes-dispatch.html">predict_classes()</a></code>: Predict classes of new samples.</li>
</ul>
</div>
<div class="section level2">
<h2 id="visualizations">Visualizations<a class="anchor" aria-label="anchor" href="#visualizations"></a>
</h2>
<p><em>cola</em> package provides rich visualizations for the results generated by a single method or multiple methods.</p>
<div class="section level3">
<h3 id="on-the-consensuspartition-object">On the ConsensusPartition object<a class="anchor" aria-label="anchor" href="#on-the-consensuspartition-object"></a>
</h3>
<p>The object which is generated with a single top-value method and a single partitioning method belongs to the class <code>ConsensusPartition</code>. There are several visualization functions that can be applied to it. <code><a href="../reference/select_partition_number-ConsensusPartition-method.html">select_partition_number()</a></code> makes several plots to show different statistics along with different <span class="math inline">\(k\)</span>, which helps to determine the “best k”.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res</span> <span class="op">=</span> <span class="va">golub_cola</span><span class="op">[</span><span class="st">"ATC:skmeans"</span><span class="op">]</span> <span class="co"># the ConsensusPartition object</span></span>
<span><span class="fu"><a href="../reference/select_partition_number-ConsensusPartition-method.html">select_partition_number</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-29-1.png" width="960" style="display: block; margin: auto;"></p>
<p>The heatmap for the consensus matrix with a certain <span class="math inline">\(k\)</span>:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/consensus_heatmap-ConsensusPartition-method.html">consensus_heatmap</a></span><span class="op">(</span><span class="va">res</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-30-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The heatmap for the membership matrix with a certain <span class="math inline">\(k\)</span>:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/membership_heatmap-ConsensusPartition-method.html">membership_heatmap</a></span><span class="op">(</span><span class="va">res</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-31-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The dimension reduction plot with a certain <span class="math inline">\(k\)</span>:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/dimension_reduction-dispatch.html">dimension_reduction</a></span><span class="op">(</span><span class="va">res</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## use UMAP</span></span></code></pre>
<p><img src="cola_general_files/figure-html/unnamed-chunk-32-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The heatmap for the signature rows with a certain <span class="math inline">\(k\)</span>. The heatmap is split into two parts by columns. The left heatmap where the barplots on top are in black contains samples with silhouette scores larger than 0.5 and the right heatmap where the barplot son top are in grey contains samples with silhouette scores less than 0.5. Rows are automatically split by k-means.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/get_signatures-dispatch.html">get_signatures</a></span><span class="op">(</span><span class="va">res</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-33-1.png" width="700" style="display: block; margin: auto;"></p>
<p><code>fdr_cutoff</code> and <code>top_signatures</code> arguments control the number of signatures shown in the heatmap.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/get_signatures-dispatch.html">get_signatures</a></span><span class="op">(</span><span class="va">res</span>, k <span class="op">=</span> <span class="fl">3</span>, top_signatures <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-34-1.png" width="700" style="display: block; margin: auto;"></p>
<p><code><a href="../reference/collect_classes-dispatch.html">collect_classes()</a></code> which is applied on the <code>ConsensusPartition</code> object visualizes how subgroups are corresponded with increasing <span class="math inline">\(k\)</span>. The same row in all heatmaps corresponds to a same sample.</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/collect_classes-dispatch.html">collect_classes</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-35-1.png" width="700" style="display: block; margin: auto;"></p>
<p><code><a href="../reference/collect_plots-dispatch.html">collect_plots()</a></code> which is applied on the <code>ConsensusPartition</code> object puts all the plots from all <span class="math inline">\(k\)</span> into one single page.</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/collect_plots-dispatch.html">collect_plots</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-36-1.png" width="1344" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="on-the-consensuspartitionlist-object">On the ConsensusPartitionList object<a class="anchor" aria-label="anchor" href="#on-the-consensuspartitionlist-object"></a>
</h3>
<p><code><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods()</a></code> returns a <code>ConsensusPartitionList</code> object. There are two main functions which can visualize results from all combinations of methods and compare directly.</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/collect_plots-dispatch.html">collect_plots</a></span><span class="op">(</span><span class="va">golub_cola</span>, fun <span class="op">=</span> <span class="va">consensus_heatmap</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-37-1.png" width="1344" style="display: block; margin: auto;"></p>
<p><code>fun</code> can also be <code>membership_heatmap</code> or <code>get_signatures</code> that membership heatmap and signature heatmap for each method will be plotted.</p>
<p><code><a href="../reference/collect_classes-dispatch.html">collect_classes()</a></code> which is applied on the <code>ConsensusPartitionList</code> object plots the partition for each combination of methods and the lightness correspond to the silhouette scores for samples in each method. Rows are clustered by the dissimilarity measurement from <code>clue::cl_dissimilarity(..., method = "comembership")</code>. On top the consensus subgroup is inferred from all methods by taking the mean silhouette scores as weight.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/collect_classes-dispatch.html">collect_classes</a></span><span class="op">(</span><span class="va">golub_cola</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-38-1.png" width="960" style="display: block; margin: auto;"></p>
<p><code><a href="../reference/collect_stats-dispatch.html">collect_stats()</a></code> helps to compare statistics from multiple methods and multiple metrics.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/collect_stats-dispatch.html">collect_stats</a></span><span class="op">(</span><span class="va">golub_cola</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="cola_general_files/figure-html/unnamed-chunk-39-1.png" width="960" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="the-html-report">The HTML report<a class="anchor" aria-label="anchor" href="#the-html-report"></a>
</h2>
<p>All the content introduced above is mainly for the deep understanding of the package. In real data analysis, users do not need to type that amount of code. <code><a href="../reference/cola_report-dispatch.html">cola_report()</a></code> function wraps all the code and performs the complete analysis automatically. Normally, applying <em>cola</em> analysis, following three lines of code are enough for you.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># code is only for demonstration</span></span>
<span><span class="va">mat</span> <span class="op">=</span> <span class="fu"><a href="../reference/adjust_matrix.html">adjust_matrix</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span> <span class="co"># for some datasets, you don't need this line.</span></span>
<span><span class="va">rl</span> <span class="op">=</span> <span class="fu"><a href="../reference/run_all_consensus_partition_methods.html">run_all_consensus_partition_methods</a></span><span class="op">(</span><span class="va">mat</span>, cores <span class="op">=</span> <span class="va">...</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/cola_report-dispatch.html">cola_report</a></span><span class="op">(</span><span class="va">rl</span>, output_dir <span class="op">=</span> <span class="va">...</span><span class="op">)</span> <span class="co"># Alles ist da!</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="real-world-examples">Real-world examples<a class="anchor" aria-label="anchor" href="#real-world-examples"></a>
</h2>
<p>More examples for <em>cola</em> analysis can be found at <a href="https://jokergoo.github.io/cola_collection/" class="external-link uri">https://jokergoo.github.io/cola_collection/</a>.</p>
</div>
<div class="section level2">
<h2 id="session-info">Session info<a class="anchor" aria-label="anchor" href="#session-info"></a>
</h2>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html" class="external-link">sessionInfo</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## R version 4.3.1 (2023-06-16)</span></span>
<span><span class="co">## Platform: x86_64-apple-darwin20 (64-bit)</span></span>
<span><span class="co">## Running under: macOS Ventura 13.2.1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Matrix products: default</span></span>
<span><span class="co">## BLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib </span></span>
<span><span class="co">## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random number generation:</span></span>
<span><span class="co">##  RNG:     L'Ecuyer-CMRG </span></span>
<span><span class="co">##  Normal:  Inversion </span></span>
<span><span class="co">##  Sample:  Rejection </span></span>
<span><span class="co">##  </span></span>
<span><span class="co">## locale:</span></span>
<span><span class="co">## [1] C/UTF-8/C/C/C/C</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## time zone: Europe/Berlin</span></span>
<span><span class="co">## tzcode source: internal</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## attached base packages:</span></span>
<span><span class="co">## [1] grid      stats     graphics  grDevices utils     datasets  methods   base     </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## other attached packages:</span></span>
<span><span class="co">## [1] GetoptLong_1.0.5      mvtnorm_1.2-3         matrixStats_1.2.0     cola_2.9.1           </span></span>
<span><span class="co">## [5] circlize_0.4.15       ComplexHeatmap_2.18.0 knitr_1.44            markdown_1.10        </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## loaded via a namespace (and not attached):</span></span>
<span><span class="co">##  [1] blob_1.2.4              bitops_1.0-7            Biostrings_2.68.1       RCurl_1.98-1.12        </span></span>
<span><span class="co">##  [5] fastmap_1.1.1           XML_3.99-0.14           digest_0.6.33           lifecycle_1.0.4        </span></span>
<span><span class="co">##  [9] cluster_2.1.4           Cairo_1.6-2             survival_3.5-8          KEGGREST_1.40.1        </span></span>
<span><span class="co">## [13] RSQLite_2.3.1           magrittr_2.0.3          genefilter_1.82.1       compiler_4.3.1         </span></span>
<span><span class="co">## [17] rlang_1.1.2             sass_0.4.8              rngtools_1.5.2          tools_4.3.1            </span></span>
<span><span class="co">## [21] yaml_2.3.7              askpass_1.2.0           brew_1.0-8              doRNG_1.8.6            </span></span>
<span><span class="co">## [25] bit_4.0.5               mclust_6.0.0            reticulate_1.34.0       xml2_1.3.6             </span></span>
<span><span class="co">## [29] eulerr_7.0.0            RColorBrewer_1.1-3      purrr_1.0.2             BiocGenerics_0.48.1    </span></span>
<span><span class="co">## [33] desc_1.4.2              stats4_4.3.1            xtable_1.8-4            colorspace_2.1-0       </span></span>
<span><span class="co">## [37] iterators_1.0.14        cli_3.6.2               rmarkdown_2.25          crayon_1.5.2           </span></span>
<span><span class="co">## [41] ragg_1.2.6              umap_0.2.10.0           RSpectra_0.16-1         httr_1.4.7             </span></span>
<span><span class="co">## [45] rjson_0.2.21            DBI_1.1.3               cachem_1.0.8            stringr_1.5.0          </span></span>
<span><span class="co">## [49] splines_4.3.1           zlibbioc_1.46.0         parallel_4.3.1          AnnotationDbi_1.62.2   </span></span>
<span><span class="co">## [53] impute_1.74.1           XVector_0.40.0          vctrs_0.6.4             Matrix_1.6-1.1         </span></span>
<span><span class="co">## [57] jsonlite_1.8.8          slam_0.1-50             IRanges_2.36.0          S4Vectors_0.40.2       </span></span>
<span><span class="co">## [61] bit64_4.0.5             irlba_2.3.5.1           clue_0.3-65             systemfonts_1.0.5      </span></span>
<span><span class="co">## [65] magick_2.8.0            foreach_1.5.2           jquerylib_0.1.4         annotate_1.78.0        </span></span>
<span><span class="co">## [69] glue_1.6.2              pkgdown_2.0.7           codetools_0.2-19        stringi_1.7.12         </span></span>
<span><span class="co">## [73] shape_1.4.6             GenomeInfoDb_1.36.4     htmltools_0.5.7         openssl_2.1.1          </span></span>
<span><span class="co">## [77] GenomeInfoDbData_1.2.10 R6_2.5.1                microbenchmark_1.4.10   textshaping_0.3.7      </span></span>
<span><span class="co">## [81] doParallel_1.0.17       rprojroot_2.0.3         evaluate_0.22           lattice_0.21-9         </span></span>
<span><span class="co">## [85] Biobase_2.60.0          png_0.1-8               memoise_2.0.1           bslib_0.6.1            </span></span>
<span><span class="co">## [89] Rcpp_1.0.11             xfun_0.40               fs_1.6.3                MatrixGenerics_1.12.3  </span></span>
<span><span class="co">## [93] skmeans_0.2-16          GlobalOptions_0.1.2</span></span></code></pre>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Zuguang Gu.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  <style>nav[data-toggle='toc'] .nav .nav {display: block;}</style>
</body>
</html>
